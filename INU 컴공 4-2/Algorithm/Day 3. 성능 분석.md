  

- 성능 분석 (performance analysis)
    - 수학적
    - 프로그램을 실행하는데 필요한 시간과 공간의 추정
- 성능 측정 (performance measurement)
    - 실측정
    - 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간 측정

  

- 공간 복잡도
    - 알고리즘을 실행시켜 완료하는데 필요한 총 저장 공간
    - 현대에 와서 하드웨어의 발달로 인해 크게 영향을 끼치지 않는다.
- 시간 복잡도
    - 알고리즘을 실행시켜 완료하는데 걸리는 시간
        - 컴파일 시간(영향 적음) + **실행 시간**

  

## 점근식 표기법

### 점근식 표기법

- Big-Oh (O)
    - f, g 가 양의 정수를 갖는 함수 일 때, 두 양의 상수 a, b 가 존재하고,  
        모든 n ≥ b에 대해 f(n) ≤ a · g(n) 이면, f(n) = O(g(n))
- Big-Omega(Ω)
    
- Big-Theta (Θ)

  

### 연산 그룹 및 시간 순서

### 연산 그룹

- 상수시간 : O(1)
- 로그시간 : O(logn)
- 선형시간 : O(n)
- n로그시간 : O(nlogn)
- 평방시간 : O(n2)
- 입방시간 : O(n3)
- 지수시간 : O(2n)
- 계승시간 : O(n!)

  

### **연산 시간의 순서**

**O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!)**

  

### 순환 (Recursion)

- 직접 순환
    - 함수가 직접 자신을 호출
- 간접 순환
    - 다른 제 3의 함수를 호출하고 그 함수가 다시 자신을 호출
- 순환 방식의 적용
    - **분할 정복**의 특성을 가진 문제에 적합

  

### [1장 시험] 점화식

[아래에서 2문제 시험]

```
다음 점화식을 풀어라.(1) C_N=C_(N-1)+N, N≥2이고 C_1=1.(2) C_N=C_(N⁄2)+1, N≥2이고 C_1=0. (3) C_N=C_(N⁄2)+N, N≥2이고 C_1=0. (4) C_N=2C_(N⁄2)+1, N≥2이고 C_1=1. (5) C_N=2C_(N⁄2)+N, N≥2이고 C_1=0. (6) C_N=2C_(N⁄2)+N^2, N≥2이고 C_1=0.
```

  

**점화식(4, 5)**

`**C_N = 2C_N/2 + 1 , N ≥2, C_1 = 1**`

- `**2C_N/2**` **: 상수 2가 붙은 이유**
    - 순환마다 처리 데이터는 반으로 줄어든다.
    - 하지만 반으로 나뉜 좌우 데이터 모두 처리를 해줘야 하는 알고리즘. (x2)

  

`N = 2^n` 으로 치환하는 이유?

- 일반적으로 계산하기 쉬워짐.
- 약간의 오차가 있을 수 있으나 큰 영향을 끼치지 않음.

  

  

#   
Chapter 2. 정렬 알고리즘

- 용어
    - `레코드` : 정렬할 각 원소.
    - `필드` : 레코드에 포함되어 있는 여러 가지 정보.
    - `키` : 레코드를 대표. 레코드 간의 순서를 나타내는 자료.

  

- 종류
    - 내부 정렬 : 주 기억 장치에 정렬할 레코드가 존재.
    - 외부 정렬 : 보조 기억 장치에 정렬할 레코드가 존재.

  

- 안정성
    - `정렬 후`에도 같은 키 값을 가지는 레코드의 상대적인 위치가 유지되면 `안정적`
    - `중복 값`을 가지는 레코드 간의 상대적 위치가 정렬 전과 후로 변하지 않으면 `안정적`

  

- 공간
    - 제자리 정렬 알고리즘 : 입력 배열 이외의 추가적 기억 장소의 수가 필요 없음.

  

- 배열 사용
    - index 0 은 사용하지 않는다.
        - 정수 배열 a[N+1]
        - a[0] : 비워둔다
        - a[1] ~ a[N] N 개의 데이터 저장.

  

  

## 1. 선택 정렬 (Selection Sort)

![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.23.56.png]]

> N개의 데이터 중  
> 1. 가장 작은 원소를 찾아 첫번째 원소와 교환.  
> 2. 두번째 작은 원소를 찾아 두번째 원소와 교환  
> … 반복

- 점화식 : C_N = C_N-1 + N
- 시간 복잡도 : O(N^2)

  

**특징**

1. 실제로 교환되는 것은 많아야 한 번 이므로 작은 키와 매우 큰 레코드를 가지는 데이터의 정렬에 적합.
2. 실행 시간은 입력 자료의 순서에 민감하지 않음.
3. 제자리 정렬
4. 불안정적

  

  

## 2. 버블 정렬

![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.31.05.png]]

> 좌측의 레코드 부터 바로 우측의 레코드와 비교했을때 큰 경우 우측으로 이동.  
> 루프를 한번 반복 할 때마다 가장 큰 값을 가진 원소가 가장 뒤쪽으로 이동함.

- 점화식 :
- 시간 복잡도 : O(N^2)

  

**특징**

- 레코드를 계속 교환하므로 레코드의 크기가 큰 경우 불리.
- 거의 정렬이 된 데이터인 경우 유리.
    - 역순으로 배치되어 있는 데이터인 경우 최악.
- 안정적인 제자리 정렬.

  

  

## 3. 삽입 정렬

![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.37.20.png]]

> 적절한 위치에 공간을 만든 후 삽입하여 정렬.  
> 카드 정렬과 유사.

- 점화식 :
- 시간 복잡도 : O(N^2)

  

**특징**

- 레코드를 계속 이동시켜야 함 (공간 창출) → 레코드의 크기가 큰 경우 불리.
- 거의 정렬이 된 데이터인 경우 유리.
- 안정적인 제자리 정렬
- 더미 키 필요 (index[0] = -1)
    - 가장 작은 값인 -1 을 index 0 에 위치시킴으로서 보다 간단하게 index 1 부터 정렬하도록 할 수 있다.

  

**선택 VS 버블 VS 삽입 정렬 간 최적의 정렬 알고리즘을 찾기 위해서는 직접 Test**

  

  

## 4. 쉘(Shell) 정렬

> 삽입 정렬을 간단하게 변형한 것.  
> 멀리 떨어진 원소끼리 교환이 가능하게 하여 정렬 속도의 향상.

- h-정렬 데이터 : 모든 h번째 원소를 정렬한 데이터.
- 점화식 :
- 시간 복잡도 :
    - 최선의 경우 : O(NlogN)
    - 평균적인 경우 : O(N^4/3)
    - 최악의 경우 : O(N^3/2)
- 제자리 정렬
- 불안정적

  

**특징**

- 쉘 정렬의 성능은 인덱스 간격 순차에 따라 달라짐.