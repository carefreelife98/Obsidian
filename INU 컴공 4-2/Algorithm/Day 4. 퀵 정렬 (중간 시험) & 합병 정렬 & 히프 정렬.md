
> 시험
> 알고리즘 & 수행과정
# Quick Sort

> **분할 정복 기법**을 사용한 정렬 방법
> - `Pivot(피봇)` 사용.
> - Pivot 을 기준으로 a[] 의 원소들을 두 개의 `Partition` 으로 분할.
> 	- `좌측` Partition 은 Pivot 보다 `작은 값`.
> 	- `우측` Partition 은 Pivot 보다 `큰 값`.
> 시간 복잡도 (N개의 원소 정렬 시) : **NlogN**
- **불안정적.**
- **제자리 정렬**
- **입력 배열의 순서에 굉장히 민감함.**

## Quick Sort Algorithm
```C
quickSort(a[], l, r)  
	// 배열 a[]의 부분 배열 a[l : r]을 오름차순으로 정렬
	if (r > l) then {  
		i ← partition(a[], l, r); 
		quickSort(a[], l, i-1); 
		quickSort(a[], i+1, r);
	}  
end quickSort()

partition(a[], l, r)
  v ← a[r];  // 가장 오른쪽 원소를 피봇으로 정함
  i ← l-1;     // 왼쪽에서 오른쪽으로 움직이는 포인터
  j ← r;        // 오른쪽에서 왼쪽으로 움직이는 포인터
  for ( ; ; ) do {
    do { i ← i + 1; } while (a[i] < v);      
    do { j ← j - 1; } while (a[j] > v);
    if (i ≥ j) then break;               
    a[i]와 a[j]를 교환;
  }
  a[i]와 a[r]를 교환;
  return i;
end partition()
```
1. `i, j, p` 지정
2. `i > p`, `j < p` 를 만족할 때까지 `i++, j--` 실행.
	- 만족한 경우 `list[i], list[j] = list[j], list[i]` (값의 교환) 
3. 1~2 과정 반복 중 `i >= j` 를 만족하는 순간 (i, j 의 역전)
	- `list[i], list[p] = list[p], list[i]` (값의 교환 및 루프 종료)
4. 이후 i 를 기준으로 좌, 우 Partition 분할 하여 1, 2, 3 과정의 반복.

## Process
![[스크린샷 2023-09-18 오후 3.15.14.png]]
- **`위와 같이 하나의 루프가 끝나면 a[i], 즉 첫번째 루프의 피봇 값은 정렬이 된다.`**
- **`이후, 정렬된 값을 기준으로 좌, 우 Partition 에서 다시 위 과정을 반복한다.`**

## 예제
```python
list = [-1, 7(i), 10, 5, 4, 9, 3, 1, 8, 2(j), 6(p)]
list = [-1, 2(i), 10, 5, 4, 9, 3, 1, 8, 7(j), 6]

list = [-1, 2, 10(i), 5, 4, 9, 3, 1(j), 8, 7, 6]
list = [-1, 2, 1(i), 5, 4, 9, 3, 10(j), 8, 7, 6]

list = [-1, 2, 1, 5, 4, 9(i), 3(j), 10, 8, 7, 6]
list = [-1, 2, 1, 5, 4, 3(i), 9(j), 10, 8, 7, 6]
list = [-1, 2, 1, 5, 4, 3(j), 9(i), 10, 8, 7, 6] # i, j 엇갈림
list = [-1, 2, 1, 5, 4, 3(j), 6(fixed), 10, 8, 7, 9(i)]

# 6 기준으로 좌, 우 Partition 반복
# 이후 과정에서도 Pivot 과 list[i] 가 바뀌어 Fix 된 요소 기준으로 좌, 우 반복.
```

## 성능 특성
- 최선의 경우 -> CN =2CN/2 +N -> **CN =NlogN**

- 평균  
	-> **CN = 2 N lnN**

- 평균 비교 횟수는 최선의 경우에 비해 약 38% 정도 많아지므로 큰 차이가 나지 않는다고 할 수 있음
	-> 2 N lnN = 1.38 N logN



# Merge Sort (합병 정렬)
> `두 개의 정렬된 File을 하나의 큰 정렬된 File 로 합병.`
> - 분할 정복 방식.
> - 두 부분 배열의 크기가 동일하도록 분할.
- **시간 복잡도는 항상 O(N logN)**
- **입력 배열에 민감하지 않음.**
- **안정적.**
- **제자리 정렬이 아님.**
	- **기억 장소가 충분한 경우 합병 정렬이 가장 이상적인 알고리즘.**

## Algorithm
```c
mergeSort(a[], l, r) 
	if (r > l) then {
		m ← (r+l)/2;
		mergeSort(a[], l, m);
		mergeSort(a[], m+1, r);
		merge(a[], l, m, r);
	}
end mergeSort()
```

## 예제
```python
# 좌
list = [7, 10, 5, 4, 9, 3, 1, 8, 2, 6, 12, 11]
list = [7, 10, 5, 4, 9, 3], [1, 8, 2, 6, 12, 11]
list = [7, 10, 5, 4, 9, 3]
list = [7, 10, 5], [4, 9, 3]
list = [7, 10], [5]
list = [7], [10]
list = [5, 7, 10]
list = [4, 9], [3]
list = [4], [9]
list = [3, 4, 9]
list = [3, 4, 5, 7, 9, 10]

# 우
list = [1, 8, 2], [6, 12, 11]
list = [1, 8], [2]
list = [1], [8]
list = [1, 8]
list = [1, 2, 8]
list = [6, 12], [11]
list = [6], [12]
list = [6, 12]
list = [6, 11, 12]
list = [1, 2, 6, 8, 11, 12]

# 결과
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

# Heap Sort (히프 정렬)
> Heap (히프) : 우선  순위 큐의 일종.
> 1. 정렬 대상 원소를 모두 공백 Heap에 하나씩 삽입.
> 2. 제일 큰 원소를 삭제
> 3. 해당 원소를 리스트의 뒤부터 차례로 삽입
> 4. 오름차 순으로 정렬된 리스트 생성
- **제자리 정렬.**
- **불안정적**
- **시간복잡도**
	- **최악 O(N logN)**
- **입력 배열의 순서에 민감하지 않음.**
- 퀵 정렬보다 약 2배 느림.