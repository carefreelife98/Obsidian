---
Author: CarefreeLife98
Date: 2023-11-08T16:04:00
Agenda: 
tags:
  - Algorithm
---
# 스트링 탐색 알고리즘의 설계
> **중점**
> - 필연적으로 잘못된 시작 (False Start) 가 발생함.
> - **False start 의 횟수와 길이를 줄이는 것이 중점.**

<br><br>
## 직선적 알고리즘

## KMP 
**\[기말 시험] next\[M]**

```python
initNext(p[]):
	M <- 패턴의 길이;
	next[0] <- -1;
	for(i <- 1, j <- 0; i < M; i <- i + 1, j <- j + 1) do {
		next[i] <- j;
		while(j >= 0 and p[i] != p[j]) do {
			j <- next[j];
		}
	}
end initNext()
```


# 트라이
> **ABRACADABRA**
> 1. 11 00 011 11 010 11 10 11 00 011 11 (25 bit)
> 2. 0 110 10 0 1111 0 1110 0 110 10 0 (23 bit - 더 효율적)

## 가장 효율적인 트라이 생성 방법 - 허프만 인코딩
> **\[기말 시험 - p43]**
> - 주어진 text 빈도 수 일일히 계산
> 
> <br>
> **\[1. 트라이 생성 과정]**
> 1. 가장 빈도수가 작은 것 2개를 최소 히프에 삽입, 트라이 생성.
> 2. 2개를 더한 값을 다시 빈도수 배열에 삽입.
> 3. 1, 2번 반복.
> <br>
> **\[2. 허프만 코드 부여]**
> 1. 생성된 트라이를 바탕으로 각 노드의 2진수 코드를 탐색.
> 2. len\[k] = 해당 코드의 길이
> 3. code\[k] = 해당 코드를 10진수로 변환한 값
> <br>
> **\[실제 코드 구현 시]**
> - k = 1 부터 Alphabet 순서에 맞춰 값을 부여.
> 	- 비어있는 문자가 존재하면 그 만큼 증가된 값을 부여해야 함.
> - dad\[k] 값이 양수면 0, 음수면 1 (어떻게 정의하든 상관없음)
> 	- dad\[k] 의 절대값은 27부터 증가.
> 	- k와 dad\[k] 값만 비교해서 27부터 증가한 절대값을 따라 이동해가며 양수면 0, 음수면 1 로서 인코딩.
> 	- 디코딩은 0111 인 경우 가장 큰 수인 41 부터 0부터 시작해서 음수, 양수 를 구분하여 이동하여 수행.

<br><br>

# 암호화 알고리즘
> N, p - 공개 키
> - N 이 어떤 두 소수의 곱으로 이루어졌는지 아는 데에는 많은 시간이 소요.
> - 

