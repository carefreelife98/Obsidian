- **k-map 을 이용한 간소화**

# Minterm 최소항
![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.21.01 1.png]]
`좌측: 2개 Input 에 대한 Minterm. 우측: 3개 Input 에 대한 Minterm.`<br>
**Minterm: each combination of the variables**
- **모든 항이 들어가는 동시에 Input 을 1로 만들어주며 `AND` 만을 사용하는 조합**
	- AND 연산이 사용되므로 `0 은 NOT 으로 변환, 1은 그대로`
	- 최소항에 대한 index는 0부터 시작하여 증가 (m0, m1, m2…)<br><br>
- **예시 (Function 을 Minterm 의 조합으로 변환)**<br>
	![[스크린샷 2023-10-28 오후 7.54.23.png]]
	- **모든 Input 이 각 항마다 존재해야 하므로 x + x' = 1 임을 잘 활용하여 항 내에 존재하지 않는 Input 을 추가해준다.**
	- Minterm 의 조합으로 나타낸 표현이므로 **Sum of Minterm** 이라고 한다. (= Canonical Form)
		- **Sum of Minterm 의 표현 방법 세 가지**
			- **Equation** : xy'z + xy'z' ...
			- **Symbol** : m0 + m1 + m2 ...
			- **Index** : ∑(0, 1, 2, 4, 5, 6, 7)
- **입력 개수와 Minterm 의 개수 간의 상관 관계**
	- **n variables -> 2^n minterms**
- **Sum of Minterm 은 Sum of Product 의 특수한 형태.**
	- 각 항이 Minterm 으로 이루어진 Sum of Product 형식.
<br><br>
## Sum of Product (SOP) , Product of Sums(POS)
1. **Sum of Product (SOP)**
    - **F = y’ + xy + x’y’z’**
        - **각 항은 OR 연산으로 구성.**
        - **모든 항은 AND 로 연결**되어 있음.
	<br><br>
2. **Product of Sums (POS)**
    - **F = y’(x + y)(x’ + y’ + z’)**
        - **각 항은 AND 연산으로 구성.**
        - **모든 항은 OR 로 연결**되어 있음.

<br><br>
## Sum of Minterm (Canonical Form)
- Sum of Product (SOP) 의 특수한 형태.
- **Canonical SOP** 라고 할 수 있음.

![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.43.09 1.png]]

- [출처]([https://blog.naver.com/cj3024/221100661940](https://blog.naver.com/cj3024/221100661940))

<br><br>

### \[기존 방법 - Sum of Minterm 구하기]

![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.29.56 1.png]]

1. **기존 수식을 Minterm 으로 변환.**
    - `x + x’` 은 항상 1 이므로 어디든 추가해서 사용 가능
2. Minterm 으로 변환된 수식을 **진리표에 따라 설정된 m (index) 으로 변환.**
3. **변환된 index으로 이루어진 수식을 sum 기호를 사용하여 마무리.**

  

  

### \[쉬운 방법 - Sum of Minterm 구하기]

1. **F(Function) 의 진리표** 구하기
2. **해당 F 의 진리표 값이 1인 곳의 Minterm을 Sum 하면 끝.**
    
    > **예시 1 (Function을 Sum of Minterm 으로 변환)**
    > ![[스크린샷 2023-10-28 오후 8.04.09.png]]
    > - **Function 의 진리표를 구한다.**
    > <br><br>
    > ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.04.04 1.png]]
    > - **Function 의 진리표에서 1인 항들을 Sum.**
    > 	- Sum of Minterm 변환 끝.
    > 
    > <br><br>
    > **예시 2 (Sum of Minterm 을 Function 으로 변환)**
    > ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.07.50 1.png]]
    > - Function 에 대한 진리표 구하기.
    > - 해당 진리표에서 1인 항들을 Equation으로 표현.
    > 
    > <br><br>
    > 
    > ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.48.23 1.png]]
    > 
    > - [출처]([https://blog.naver.com/cj3024/221100661940](https://blog.naver.com/cj3024/221100661940))    

<br><br>

## 카르노 맵 (Karnaugh map) 을 이용한 Boolean Function의 간소화

**준비**

- Variables 및 Minterm 진리표
<br><br>
**전체 모습**
![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.15.50 1.png]]
**특징**
- Kmap 의 Cell 개수는 Minterm의 개수와 같다.
<br><br>
**예시**

> **예시 (Variable 2개)**
> ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.15.35 1.png]]
> `상단: K-map 기본 Frame / 하단: 예시`
> - **두 개 Variable의 Minterm 진리표** 구하기.
> - **해당 진리표를 참고하여 K-map** 그리기.
> - 진리표와 K-map 을 참고하여 **K-map 의 각 Cell 에 Indexing** 하기.
> <br><br>
> **예시**
> - 2개 Variable 에 대한 진리표 값이 1인 항의 Index 를 찾는다. (1, 2)
> - 해당 Index 를 가진 K-map 의 Cell 에 1 표시 및 Minterm 찾기. (A'B, AB')

  

> **예시 (Variable 3개)**
> ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.20.13 1.png]]
> - **Variable 이 세 개인 경우 Kmap의 각 Cell에 대한 Indexing 순서 중요.**<br>
> 	0 , 1 , 3 , 2<br>
> 	4 , 5 , 7 , 6<br><br>
> **예시 (F = m1 + m2 + m4)**
> ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.23.34 1.png]]

<br><br>  

> **예시 (Variable 4개)**
> ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.05.06 1.png]]
> - **K-map Indexing 순서 확인**
> <br><br>
> **K-map 을 사용한 간소화**
> ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.09.12 1.png]]
> 
> - **Cell 묶기 (각 Cell은 OR, + 로 연결됨)**
>     - **2 Cells**
>         - `(m0, m1) → A’B’C’`
>         - 하나의 Variable 탈락 **(3 Variables 로 간소화)**
>     - **4 Cells**
>         - `(m0, m1, m4, m5) → A’C’`
>         - 두 개의 Variable 탈락 **(2 Variables 로 간소화)**
>     - **8 Cells**
>         - `(m0, m1, m4, m5, m12, m13, m8, m9) → C’`
>         - 세 개의 Variable 탈락 **(1 Variables 로 간소화)**
> - **결론**
>     - **Cell 을 묶는 건 근접한 Cell 만 가능.**
>         - 근접: 변 (모서리X)
>     - **2의 제곱 단위로 묶어야 한다.**
>     - **묶을 때 Cell의 개수는 최대화, Group의 개수는 최소화**
> 	    - Cell 을 묶는 과정에서 **중복되는 부분이 발생하더라도 최대화** 하여 묶음.
>     - **Cell 을 묶을 시 K map 을 보았을 때 관련이 없어지는 Variable 은 제외가 되어 간소화 된다.**
>     - **Kmap 을 사용한 간소화의 결과는 SOP 형식으로 반환된다.**
> - **예시**
>     ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.37.36 1.png]]
>     - Input Variables: 3개
>     ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.37.36 1.png]]
>     ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.40.37 1.png]]
>     
>     ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.45.25 1.png]]
>     
>       
>     
>     **조금 다른 형태의 문제**
>     
>     ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.50.28 1.png]]
>     
>     - **Kmap 을 사용한 간소화의 결과는 SOP 형식으로 반환된다.**
>     
>       
>     
>     **POS 형식으로 변환하기**
>     
>     ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.56.12 1.png]]
>     
>     - 위**와 같이 Cell의 값이 1 이 아닌, 0인 항을 묶으면 된다.**
>     
>       
>     
>     **SOP로 변환 후 NAND Gateway 만을 사용해서 다이어그램 그리기**
>     
>     1. 기존 다이어그램
>         
>         ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.05.47 1.png]]
>         
>     
>       
>     
>     1. NAND 만을 사용한 다이어그램 변환
>         
>         ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.01.08 1.png]]
>         
>         - NOT 을 Inverter 앞 뒤에 추가하여 로직의 변경없이 NAND 만을 사용한 다이어그램으로 변환이 가능하다.
>     
>       
>     
>     **POS 변환 후 NOR Gateway 만을 사용해서 다이어그램 그리기**
>     
>     1. 기존 다이어그램
>         
>         ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.05.16 1.png]]
>         
>     2. NOR Gateway 만을 사용한 다이어그램
>         
>         ![[%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.03.33 1.png]]
>         
>         - NOT 을 Inverter 앞 뒤에 추가하여 로직의 변경없이 NOR 만을 사용한 다이어그램으로 변환이 가능하다.