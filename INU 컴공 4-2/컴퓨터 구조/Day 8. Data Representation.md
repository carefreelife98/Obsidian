---
Author: CarefreeLife98
Date: 2023-10-11T13:30:00
Agenda: |-
  1. Data Types
  2. Complements
tags:
  - Computer_Structure
---
# Data Types
## Number System
> ![[스크린샷 2023-10-09 오후 5.16.18.png]]
> - **Decimal (10 진수 - base : 10)**
> 	- 0 ~ 9 로 표현.
> <br><br>
>![[스크린샷 2023-10-09 오후 5.20.45.png]]
> - **Binary Number (2진수 - base: 2)**
> 	- 0, 1 으로 표현
> 	- Binary Number 로 표기 시 숫자가 길어지므로 8진수 (Octal), 16진수(Hexadecimal) 등으로 표현하게 된다.
> <br><br>
> **Conversion (진수 변환)**
> ![[스크린샷 2023-10-09 오후 5.35.16.png]]
> - 위처럼 2진수를 쉽게 8진수, 16진수로 변환 할 수 있다.
> 	- **2진수 -> 8진수**
> 		- 8진수는 2진수의 세 자리수로 나타낼 수 있다.
> 		- 따라서 **2진수의 자릿수를 3개씩 묶어 앞에서부터 읽으면 8진수로 변환 가능.**
> 	- **2진수 -> 16진수**
> 		- 16진수는 2진수의 네 자리수로 나타낼 수 있다.
> 		- 따라서 **2진수의 자릿수를 4개씩 묶어 앞에서부터 읽으면 16진수로 변환 가능.**

<br><br>

## Binary Coded Decimal Number (BCD)
![[스크린샷 2023-10-09 오후 5.45.05.png]]
> **10진수를 2진수로 표현 한 것.**
> - 0 ~ 9 의 10진수를 2진수, 즉 **0000 ~ 1001** 까지 표현한 것.
> 	- 따라서 10진수 관점에서 자릿수가 하나 늘어날 때마다 BCD 는 4개의 Bit 가 추가됨.
> 	- 따라서 10에 해당되는 **1010** 부터 15에 해당되는 **1111** 까지는 **BCD 에서 사용하지 않는다.**

<br><br>

# Complements (보수)
> **Complements (보수) 는 - 숫자 (음수) 에 대한 표현 방식을 이해하기 위해 배운다.**
> - 컴퓨터가 기본적으로 수행하지 못하는 뺄셈 연산을 수행 가능케 함.
> Base : r

## 수학적 정의
### 1. (r-1)'s

```
n: N의 자리수
r: 진수

수학적 정의 : (r^n - 1) - N
```

![[스크린샷 2023-10-09 오후 6.03.10.png]]
> - **r = 2 (2진수) 인 경우**
> 	- **1's (1의 보수)**
> 		- (2^n - 1) - N
> 		- **2진수의 각 자리수를 반전을 시키면 1의 보수화 가능.**
> - **r = 10 (10진수) 인 경우**
> 	- **9's (9의 보수)**
> 		- (10^n - 1) - N

<br><br>

### r's
```
n: N의 자리수
r: 진수

수학적 정의 : r^n - N = (r^n - 1) - N + 1
= (r-1)'s + 1
```


> - **r = 2 (2진수) 인 경우**
> 	- **2's (2의 보수)**
> 		- 2^n - N = (2^n - 1) - N + 1 = **1's + 1**
> 	- **편하게 2의 보수를 구하는 방법**
> 		- 해당 2진수의 첫 자릿수부터 시작하여 처음 만나는 1 까지 이동.
> 		- 1을 만난 다음 자릿수 부터 0과 1을 반전하면 쉽게 2의 보수를 구할 수 있다.
> - **r = 10 (10진수) 인 경우**
> 	- **10's (10의 보수)**
> 		- 10^n - N = (10^n - 1) - N + 1 = **9's + 1**

<br><br>
## Complements 를 이용한 뺄셈
![[스크린샷 2023-10-11 오후 1.42.29.png]]
> **음수 값을 더해 뺄셈을 구현.**
> - `M - N = M + (-N)`
> - `= M + (2^n - N)`
> - `= 2^n + (M - N)`
> 	- **2^n 은 end carry 로서 버린다.**

<br><br>

**Case 1. M >= N**
> 
> 1. 2의 보수를 구한 후 더한다.
> 2. end carry, 2^n 을 버린다.

<br><br>

**Case 2. M < N (Negative - 음의 결과)**
> 2^n - (N - M)
> - `= 2's of (N - M)`
> - N - M 의 2의 보수를 취한다.

<br><br>
### Complements 를 이용한 뺄셈 예시
> **x**
> - 84 = 1010100
> **y**
> - 67 = 1000011

<br><br>
#### Case 1
![[스크린샷 2023-10-11 오후 1.48.33.png]]
> **x - y = 17**
> 01010100 - 01000011
> - **01000011 의 2의 보수를 취한 후 더해준다.**
> 	- **`= 100010001`**
> - 8비트 연산에서 8비트의 **범위를 넘어가는 수는 end carry 로서 버린다.**
> 	- **`= 00010001`**

<br><br>
#### Case 2
![[스크린샷 2023-10-11 오후 1.55.16.png]]
> **y - x = -17**
> 01000011 - 01010100
> - **01010100 의 2의 보수를 취한 후 더해준다.**
> 	- **`= 11101111`**
> 	- **= 17에 대한 2의 보수**
> 		- **즉, 처음 계산했던 17 에 (-) 를 붙혀준 것과 같다.**

<br><br>








# Fixed Point Representation
> 음수를 어떻게 표현하는가?
> <br>
> 세 가지 방법 존재.
> - **Signed magnitude representation**
> 	- 부호 크기 방식
> 		- **최상위 비트를 부호로 표현.**
> - **Signed 1's complement representation**
> 	- 1의 보수 형태로 음수를 표현
> - **Signed 2's complement representation**
> 	- 2의 보수 형태로 음수를 표현

<br><br>

## Signed Magnitude Representation
![[스크린샷 2023-10-11 오후 2.10.03.png]]
> - 부호 크기 방식
> 	- **최상위 비트를 부호로 표현.**
> - **두 수 (양수 & 음수) 의 절대 값이 같은 경우**
> 	- **최상위 비트를 제외한 나머지 비트는 같고, 최상위 비트가 0이면 음수, 1이면 양수.**
> - 0이 두 개이다.
> 	- +0 과 -0
> 	- 0이 두 개이므로 3bit 로 표현할 수 있는 최대 가짓수는 8가지가 아닌 7가지.

<br><br>

## Signed 1's Complement Representation
![[스크린샷 2023-10-11 오후 2.15.44.png]]
> **1의 보수 표현 방식.**
> - 음수를 1의 보수를 사용하여 표현한다.
> 	- x 의 1의 보수 : x의 모든 비트 값을 반전 시킨다.
> <br>
> - Magnitude Representation 과 마찬가지로 0이 두 개 존재. (+0, -0)
> 	- 0이 두 개이므로 3bit 로 표현할 수 있는 최대 가짓수는 8가지가 아닌 7가지.

<br><br>

## Signed 2's Complement Representation
![[스크린샷 2023-10-11 오후 2.28.01.png]]
> **2의 보수 표현 방식.**
> - **음수를 2의 보수를 사용하여 표현한다.**
> 	- x 의 2의 보수 : x 의 첫 비트부터 처음 나오는 1까지는 그대로 두고, 이후의 비트를 전부 반전.
> - **0이 하나 (0)**
> 	- 따라서, **3Bit 로 8개의 수를 나타낼 수 있으며**, 이와 같은 이유에서 2's Complement Representation 을 많이 사용함. (효율적)
> 	- 0 이 하나 존재하므로 **음수와 양수 값이 비대칭적**으로 나타남.
> - **2의 보수로 표현된 음수를 다시 10진수로 변환하기**
> 	- 방법 1
> 		1. 2의 보수로 표현된 음수 -2 = 110 
> 		2. 2의 보수를 취한다.
> 		3. 010 (= 2)
> 		4. 부호를 (-) 로 취해준다. (= -2)
> 		<br>
> 	- 방법 2.
> 		1. 2의 보수로 표현된 음수 -2 = 110
> 		2. 최상위 비트를 음수값으로 설정. (= -4)
> 		3. 나머지 비트를 양수값으로 설정. (2, 0)
> 		4. 최상위 비트(음수) 와 나머지 비트(양수) 를 더해준다. (= -4 + 2 + 0 = -2)
> <br>


### 2의 보수에서 최대값 과 최소값
![[스크린샷 2023-10-11 오후 2.43.52.png]]
![[스크린샷 2023-10-11 오후 2.46.12.png]]
> - **MAX** 
> 	- **최대값은 양수 값이므로 최상위 비트는 0이어야 하며, 나머지 비트는 전부 채워져야 함.**
> 	- 011 = +3
> - **MIN**
> 	- **최소값은 음수 값이므로 최상위 비트는 1이어야 하며, 나머지 비트는 전부 비워져 있어야 함.**
> 	- 100 = -4
> - Zero
> 	- 0000
> - **-1**
> 	- **2's Complement 에서 -1 은 비트 단위에 상관없이 모든 비트가 1**로 채워진다.

<br><br>

## 4-Bit (Signed-Mag, 1's, 2's)
![[스크린샷 2023-10-11 오후 2.35.14.png]]
<br><br>

## Overflow
![[스크린샷 2023-10-11 오후 2.53.37.png]]
> **(2's Complement Rep.) 4Bit System 에서 4 + 5 는 무엇일까?**
> - 0100 (4) + 0101 (5) = 1001 (?)
> 	- **위의 식에서 1001 은 9인가?**
> 		- 아니다.
> 	- 최상위 비트가 1이므로 음수이고, -8 + 1 = -7 인 것.
> - 애초에 2's Complement 로 표현된 4Bit System은 이전에 보았듯 최대값이 7이고, 최소 값이 -8 이다.
> 	- **n Bit System에서 표현하고자 하는 수가 해당 System의 최대, 최소 범위를 넘게 되면 위와 같은 Overflow 가 발생하는 것.**

<br><br>

### 8-Bit Overflow
![[스크린샷 2023-10-11 오후 2.56.07.png]]
> **8-Bit System 은 최대 127 까지 표현 가능.** 
> - 그 범위가 넘는 150 이라는 값을 표현하려 했으므로 **Overflow 발생.**

<br><br>

# Floating Point Representation
![[스크린샷 2023-10-11 오후 3.16.01.png]]
> **IEEE 표준 부동 소수점이 존재하는 값을 2진법으로 표현하는 방법.**
> **`V = (-1)^s * M * 2^E`**
> - **s (Sign Bit) = 0 or 1**
> 	- 양수이면 0, 음수이면 1
> - **M (Significand. 가수) = Fraction**
> - **E (Exponent) = 지수**
> 	- **s, M, E 를 2진법으로 변환하여 표현.**

<br><br>

## Precision (정확도)
![[스크린샷 2023-10-11 오후 3.20.35.png]]
> - **Single precision (= 32 Bits = Float)**
> 	- 첫비트 = Sign Bit (1 Bit)
> 	- exp = 8 Bits
> 	- frac = 23 Bits
> <br>
> - **Double precision (= 64 Bits = Double)**
> 	- **Single precision 에 비해 더 많고 정확한 숫자의 표현이 가능.**
> 	- 첫비트 = Sign Bit (1 Bit)
> 	- exp = 11 Bits
> 	- frac = 52 Bits

<br><br>

## 세 가지 인코딩 방법 - Normalized, Denormalized, Special Cases
### Normalized
![[스크린샷 2023-10-11 오후 3.27.56.png]]
> **Exponent 부분 Bit가 전부 0 이거나 255 이지 않은 경우**

<br><br>
![[스크린샷 2023-10-11 오후 3.40.00.png]]
> **`(-1)^s * M * 2^E`**
> - **Exp = E + Bias (127 or 1023)** 
> 	- Bias = 2^(k-1) - 1
> 		- k : Number of Exponent Bit (Exp 의 비트수 - Single : 8, Double : 11)
> 		- **Single 인 경우 Bias : 2^7 - 1 = 127**
> 		- **Double 인 경우 Bias : 2^10 - 1 = 1023**
> 	- **위에서 구한 Exp를 2진수로 변환하여 exp 8-Bit 자리에 삽입.**
> <br><br>
> - **M = 1xxxx (이진 표현, 1.0 ~ 2-E 범위, E: 입실론. 아주 작은 수)**
> 	- 1을 제외한 나머지 부분을 frac 부분에 삽입.

<br><br>

**Normalized Number 예시 1**
![[스크린샷 2023-10-11 오후 3.49.42.png]]
> **15213.0 (= 11101101101101)**
> - 위 이진수를 **`(-1)^s * M * 2^E`** 형식으로 표현
> 	- **1.1101101101101 * 2^13**
> 		- s = 0
> 		- M = 1101101101101
> 		- E = 13
> 		- Exp
> 			- E+Bias = 13+127 = 140 = 10001100
> 	- 0  (100 0110 0)  (110 1101 1011 0100 0000 0000)
> 		- **s((-1)^0) exp(100 0110 0) frac(110 1101 1011 0100 0000 0000)**
> 		- 4Bit 로 쪼개어 나타내게 되면 16진수 표현.
> 			- **466DB400**

<br><br>

**Normalized Number 예시 2**
![[스크린샷 2023-10-12 오후 4.53.19.png]]
> **12345.0 -> (-1)^s * M * 2^E**
> - 1100 0000 1110 01
> - 1.1000000 111001 * 2^13
> <br>
> Sign Bit (s): 0
> Significant: 100 0000 1110 0100 0000 0000
> exp: E + bias = 13+127 = 140 = 1000 1100
> <br>
> **최종: 0100 0110 0100 0000 1110 0100 0000 0000**
> - **16진수 : 4640E400**

<br><br>

### Denormalized
![[스크린샷 2023-10-11 오후 3.28.05.png]]
![[스크린샷 2023-10-12 오후 5.04.06.png]]
> **Exponent 부분 Bit가 전부 0 인 경우**
> - Normalized 보다 더 작은 수 이다.
> <br>
> **E = 1 - Bias**
> <br>
> **Significand value M = 0.xxx ... x (0.f)**
> - xxx ... x : Bits of frac
> - **Special Cases**
> 	- **exp = 000 ... 0, frac = 000 ... 0 (exp 와 frac 모두 0인 경우)**
> 		- 0을 나타냄 (+0, -0)
> 	- **exp 는 전부 0이나, frac 은 전부 0 이 아닌 경우**
> 		- 아주 작은 수를 나타냄. (0에 근접)

<br><br>
### Special Values
![[스크린샷 2023-10-11 오후 3.29.53.png]]
1. **Infinity**
	- **exp 가 모두 1 이고, frac 이 모두 0 인 경우**
	- **Infinity, 무한대를 나타냄.**
		- +무한 과 -무한 존재.
		<br>
2. **NaN**
	- **exp 가 모두 1 이지만, frac 이 0이 아닌 경우.**
	- 숫자가 아님. (NaN)

<br><br>

## 숫자의 범위

### Normalized 숫자의 범위
![[스크린샷 2023-10-12 오후 5.29.37.png]]
**Smallest Normalized**
> **Zero**
> 	- 0 00000001 0000 ... 0
> 		- exp = 1
> 		- E = 1 - Bias = -126
> 		- **1.0 * 2^(-126)**
> <br>
> **One**
> 	- 1은 1 * 2^0, M = 1.0
> 		- E = 0
> 		- exp = E + Bias = 127
> 		- 0. 0111 1111 0000 ... 0

<br>
**Largest Normalized**
> **가장 큰 숫자 : 0 1111 1110 1111 ... 1**
> - s = 0
> - exp = 254
> - E = 254 - 127 = 127
> - 1.1111 ... 1 은 2보다 조금 작은 수
> 	- 2-E
> - **최종 : (2-E) * 2^127**


> **Normalized 숫자의 범위**
> 
> **Smallest Normalized ~ 0 ~ Largest Normalized**
> = **1 * 2^(-126) ~ 0 ~ (2-E) * 2^127**

<br><br>
## Normalized & Denormalized 숫자 범위
![[스크린샷 2023-10-12 오후 5.37.02.png]]
<br><br>
# Other Binary Codes
## 4-Bit Gray Code
![[스크린샷 2023-10-16 오후 5.28.11.png]]
> **XOR Function**
> - 두 비트가 같으면 0, 다르면 1
> <br>
> **Binary Code 의 인접한 Bit 간 XOR 연산 후 반환되는 결과값이 Gray Code.**
> - 최상위 Bit 는 그대로 사용, 그 이후의 하위 Bit 부터 상호 간 XOR 연산.
> <br>
> **Gray Code 를 다시 Binary Code 로 복구하기**
> - Binary -> Gray 때와 비슷하지만 기존 Bit 간의 XOR 연산이 아님.
> 	- 최상위 Bit 는 그대로 사용, 그 이후에 존재하는 **하위 Bit 의 XOR 연산 결과 값을 기존 Bit 와 XOR 연산해나감.**
> <br>
> **Gray Code 의 특징**
> ![[스크린샷 2023-10-17 오전 6.58.30.png]]
> - 인접한 Gray Code 끼리의 차이는 **하나의 비트 차이.**
> 	- Ex) (0000 <-> 0001), (0011 <->0010), (0111 <-> 0101) ...

<br><br>

## BCD Code (8421 Code) / Excess-3 Code
![[스크린샷 2023-10-17 오전 6.58.03.png]]
> **BCD Code**
> - **Decimal Number (10 진수 표현) 0 ~ 9 를 4 Bit 로 표현한 것.**
> <br>
> **Excess-3 Code**
> - **BCD Code 에 3을 더해** 표현한 것.

<br><br>

# Error Detecting Code
## Parity Bit
![[스크린샷 2023-10-17 오전 7.05.05.png]]
> **Even Parity Bit (짝수)**
> - **1의 개수를 짝수**로 만들어주는 Paraty Bit (0 or 1)
> <br>
> **Odd Parity Bit (홀수)**
> - **1의 개수를 홀수**로 만들어주는 Paraty Bit (0 or 1)

<br><br>
## Even Parity Bit / Odd Parity Bit 생성하기
![[스크린샷 2023-10-17 오전 7.09.52.png]]
> **Multiple XOR Function**
> - 교환법칙 성립
> - **Input 의 1의 개수**
> 	- **홀수 개인 경우 1반환**
> 	- **짝수 개인 경우 0반환**

<br><br>
![[스크린샷 2023-10-17 오전 7.21.18.png]]
> 위의 Multiple XOR Function 의 특징에 따라서, **특정 Binary Code 의 Parity Bit를 구하려면 해당 Code 의 모든 Bit 간 XOR 연산을 수행**하면 된다.
> - 이 경우, 
		- **해당 Code 내 1의 개수가 홀수 개이면 1을 반환**
		- **해당 Code 내 1의 개수가 짝수 개이면 0을 반환**
> - 따라서, **해당 Code 의 모든 Bit 간 XOR 연산의 반환 값을 해당 Code에 추가해주면 Even Parity Bit 생성 가능.**
> - 또한, **같은 원리로 Parity Bit 의 역 (NOT, (Parity_bit)' ) 을 취해준다면 Odd Parity Bit 도 생성 가능하다**.

<br><br>
## Parity Bit 를 사용하여 Error Detection 하기
![[스크린샷 2023-10-17 오전 7.36.13.png]]
![[스크린샷 2023-10-17 오전 7.41.17.png]]
![[스크린샷 2023-10-17 오전 7.39.51.png]]
> **Error 로 인해 하나의 Bit 가 바뀌게 되는 경우 Detection 가능.**
> **Transmitter 에서 (D_1D_2D_3 .. D_n) 과 같은 Binary Code 를 전송**하고, **Transmission Line 을 거쳐 Receiver 가 수신**하게 된다.
> - Transmission Line 을 통해 전송되던 중 Error 가 발생하여 **전송된 Bit 중 하나의 Bit 가 바뀔 수 있다.**
> - 이 경우 **Parity Bit 를 기존 Bit에 추가하여 전송하게 되면, 전송 시의 Bit 정보(1의 개수) 를 담을 수 있게 된다.**
> 	- Ex) 
> 		- 7개의 Bit 로 이루어진 Binary Code 에 Even Parity Bit를 붙여 전송하게 되면, **Even Parity Bit 를 포함하여 1의 개수가 짝수인 Code를 전송했다는 것.**
> 		- 따라서 **Receiver 에서 Data 와 Parity Bit를 받아 1의 개수가 짝수이면 Error 가 없는 것이고, 홀수이면 중간 전송 과정에서 Error 가 발생함을 알 수 있게 된다.**



 
# In-Class
## Quiz
![[KakaoTalk_Photo_2023-10-10-20-18-33.jpeg]]
