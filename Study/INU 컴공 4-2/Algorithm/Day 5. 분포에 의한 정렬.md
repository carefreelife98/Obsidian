> 이전에 배운 것은 비교 기반 정렬.
> - N logN 보다 빠른 알고리즘 구축 불가능.
> - 하지만 **특별한 경우, 분포에 의한 정렬 알고리즘은 더 빠른 정렬 알고리즘 구현 가능.**

# 계수 정렬 (Counting Sort)
> **적용 범위**
> - **추가 기억 장소가 키의 범위에 비례하여 요구됨.**
> 	- 입력 키가 특정 범위내에 존재할 때 적용 가능.
> 	- EX) 입력 키가 1 부터 k 사이의 작은 정수 범위 내에 존재하는 것을 알고 있을 때.

## 구현
1. 기존 배열에 temp 배열 및 Count 배열과 같은 추가 기억 장소 마련.
	- Count [] 는 기존 배열 내의 원소 중 같은 값을 가진 원소의 개수를 Count.
2. 알고리즘은 기존 배열의 가장 우측 index 부터 시작한다.


## 예제
3 4 4 1 2 4 1 2 3 1  count[3, 2, 2, 3] -> O(N)

	-> count [3, 3 + 2, 3 + 2 + 2, 3 + 2 + 2 + 3]

3 4 4 1 2 4 1 2 3 1  count[3, 5, 7, 10] -> O(M)


# (시험 가능) 기수 정렬 (Radix Sort) 
> **전체 키를 여러 자리로 나누어 각 자리마다 계수 정렬과 같은 `안정적인 정렬 알고리즘`을 적용.**


## 수행 과정
> **십진수 기준 각 자리수의 끝자리 기준으로 Queue 생성.**
> 	- 십진수는 0 ~ 9 이 끝자리가 된다.
> 	- 0 ~ 9 의 값을 가진 10개의 Queue 생성.
> **대상 자리수를 하나씩 올려가며 동일한 Queue 에 삽입하여 정렬.**
> 	- 1의 자리 -> 10의 자리 -> 100의 자리 ...

```
# 초기 상태 배열 : [326, 472, 123, 814, 291, 567, 765, 632]

# Queue 생성 및 삽입

(1의 자리수 )
Q[0]: 
Q[1]: 291
Q[2]: 472 632
Q[3]: 123
Q[4]: 814 
Q[5]: 765 
Q[6]: 326
Q[7]: 567
Q[8]:
Q[9]:

[291 472 632 123 814 765 326 567]

(10의 자리수)
Q[0]: 
Q[1]: 814
Q[2]: 123 326
Q[3]: 632
Q[4]: 
Q[5]: 
Q[6]: 765 567
Q[7]: 472
Q[8]: 
Q[9]: 291

[814 123 326 632 765 567 472 291]

(100의 자리수)
Q[0]: 
Q[1]: 123
Q[2]: 291
Q[3]: 326
Q[4]: 472
Q[5]: 567
Q[6]: 632
Q[7]: 765
Q[8]: 814
Q[9]: 

완성 -> [123, 291, 326, 472, 567, 632 ,765, 814]
```

# 탐색 알고리즘(Searching)
> 내부 탐색
> 외부 탐색
## 순차 탐색 (Sequential Searching)
> **비교 횟수**
> - **정렬이 되어 있는 연결 리스트**
> 	- 성공적인 탐색, 성공적이지 않은 탐색
> 		- `둘 다 평균적으로 N/2 회 비교.`
> 
> - **정렬이 되어 있지 않은 연결 리스트**
> 	- 성공적인 탐색
> 		- `평균적으로 N/2 회 비교.`
> 	- 성공적이지 않은 탐색
> 		- `N+1 회 비교.`

### 순차 탐색의 성능 향상 전략
> **접근 빈도 수를 알 때**
> - 빈도 수가 가장 높은 레코드 부터 저장.
>
> **접근 빈도 수를 모를 때**
> - "자체 - 조직 (Self - Organizing)" 탐색
> - 연결리스트로 구현하는 것이 적합.
> - 많은 접근이 인접한 레코드에 대해 이루어지는 경우에 성능 향상 효과.


## 이진 탐색 (Binary Search)
> **분할 - 정복 (Divide and Conquer)**
> 
> **레코드가 정렬이 되어 있어야 사용 가능.**
> 	- 리스트를 정렬된 상태로 유지하는데 추가적인 비용 소모.
> 
> **성능 특성**
> 	- 성공적인 탐색 & 성공적이지 않은 탐색 모두 LogN + 1 회 이하의 비교.
> 		- CN = C_N/2 + 1



## 이진 트리 탐색
> **이진 탐색 트리 (Binary Tree Search)**
> 	- Root node 보다 작은 키를 가지고 있는 모든 레코드는 좌측 Subtree 에 존재.
> 	- Root node 보다 큰 키를 가지고 있는 모든 레코드는 우측 Subtree 에 존재.
> 
> 탐색 과정
> 	- 루트와 주어진 키를 비교
> 	- 키가 루트보다 작다면, 좌측 Subtree 로 이동.
> 	- 
>
> **이진 탐색 트리를 중위 순회 시 정렬된 값 도출.**
> 
> **편향(경사) 트리 (Skewed) 발생 시 최악의 성능**
> 	- 순차 탐색과 같은 성능을 보이게 된다.



